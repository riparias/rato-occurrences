---
title: "Darwin Core mapping"
subtitle: "For: The (...) occurrences of "
author:
- author_1
- author_2
date: "`r Sys.Date()`"
output:
  html_document:
    df_print: paged
    number_sections: yes
    toc: yes
    toc_depth: 3
    toc_float: yes
#  pdf_document:
#    df_print: kable
#    number_sections: yes
#    toc: yes
#    toc_depth: 3
---

# Setup 

```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = TRUE)
```

Install required libraries (only if the libraries have not been installed before):

```{r}
installed <- rownames(installed.packages())
required <- c("tidyverse", "tidylog", "magrittr", "here", "janitor", "readxl", "digest", "rgbif")
if (!all(required %in% installed)) {
  install.packages(required[!required %in% installed])
}
```

Load libraries:

```{r message = FALSE}
library(tidyverse)      # To do data science
library(magrittr)       # To use %<>% pipes
library(here)           # To find files
library(janitor)        # To clean input data
library(digest)         # To generate hashes
library(rgbif)
library(sf)
```

# Read source data

Create a data frame `input_data` from the source data:

```{r}
raw_data <- readr::read_csv(
  here::here("data", "raw", "rato_data.csv")
) 
```

Rename `raw_data` to `input_data` so we can keep original values 

```{r}
input_data <- raw_data
```


# Process source data

## Tidy data

Clean data somewhat:

```{r}
input_data <- 
  input_data %>% 
    remove_empty("rows") %>% 
    clean_names()
```

`object_id` is the unique identifier for each occurrence. This will be the `occurrenceID`. This field should contain unique values only. 
`dossier_id` is the unique identifier for each sampling event. This will be the `eventID`

Check whether `object_id` is unique (value should be `0`)

```{r}
anyDuplicated(input_data$objectid)
```
Remove all rows for `Domein` = `Werken` 

```{r}
input_data %<>% filter(domein != "Werken")
```

## Define eventID and occurrenceID

```{r}
input_data <- 
  input_data %>% 
    mutate(event_id = dossier_id) %>% 
    mutate(occurrence_id = objectid)

```

## Extract information from "waarnemingen"  

The field `waarnemingen` is used to map `organismQuantity`, `organismQuantityType` and `occurrenceStatus`. This fields need to be cleaned before mapping. 

```{r}
input_data %>% 
  group_by(waarneming) %>% 
  summarise(records = n()) %>% 
  arrange(waarneming)
```

First, we need to clean `Haard vastgesteld = 0; Waarneming onzeker = 1;`. This should be `Waarneming onzeker = 1;` (error in database):

```{r}
input_data %<>% mutate(waarneming = recode(waarneming,
  "Haard vastgesteld = 0; Waarneming onzeker = 1;" = "Waarneming onzeker = 1;"))
```

Split into different columns: `waarneming_type` and `waarneming_kwantiteit`:

```{r}
input_data <- 
  input_data %>% 

    # First, separate `waarneming` into `waarneming_type` and `waarneming_kwantiteit`:
    separate(                                   
      col = waarneming,
      into = c("waarneming_type", "waarneming_kwantiteit"),
      sep = "\\s=\\s",
      remove = FALSE) %>% 

    # Clean waarneming_kwantiteit:
    mutate(waarneming_kwantiteit = str_remove(
      string = waarneming_kwantiteit,
      pattern = ";"))
```

Map `Organism_quantity`:

```{r}
input_data %<>% 
  mutate(organism_quantity = case_when(
    waarneming_type == "Vastgesteld (in m²)" |
    waarneming_type == "Vastgesteld (aantal)" |
    waarneming_type == "Secundair nest vastgesteld" ~ waarneming_kwantiteit,
    TRUE ~ ""
  )) 
```

Map `organism_quantity_type`:

```{r}
input_data <-
  input_data %>% 
    mutate(organism_quantity_type = case_when(
      waarneming_type == "Vastgesteld (in m²)" ~ "square meter(s)",
      waarneming_type == "Vastgesteld (aantal)" ~ "individual(s)",
      waarneming_type == "Secundair nest vastgesteld" ~ "nest",
      TRUE ~ ""
    ))
``` 

Map `occurrence_status`:

```{r}
input_data <-
  input_data %>%
    mutate(occurrence_status = case_when(
      waarneming_type == "Haard vastgesteld" |
      waarneming_type == "Nest vastgesteld" |
      waarneming_type == "Vastgesteld" |
      waarneming_type == "Vastgesteld (in m²)" |
      waarneming_type == "Vastgesteld (aantal)" |
      waarneming_type == "Secundair nest vastgesteld"
        ~ "present",
      
      waarneming_type == "Geen haard vastgesteld" |
      waarneming_type == "Niet vastgesteld" 
        ~ "absent",
      
      waarneming_type == "Waarneming onzeker" ~ "doubtful",
      
      TRUE ~ ""
    ))
```

Screen mapping:

```{r}
input_data %>% 
  group_by(waarneming, organism_quantity, organism_quantity_type, occurrence_status) %>% 
  summarize(records = n()) 
```

## Extract information from "materiaal_vast"  

Information from `materiaal_vast` can be used for `samplingProtocol`

```{r}
input_data %>% 
  group_by(materiaal_vast) %>% 
  summarise(records = n()) %>% 
  arrange (records)
```

First split on ";" and separate on "="

```{r}
sampling_protocol <-
  input_data %>% 
    select(occurrence_id, materiaal_vast) %>% 

    # separate on ";" and split in different rows:
    separate_rows(
      "materiaal_vast",
      sep = ";") %>% 
  
    # remove rows for which materiaal_vast is empty:
    filter(materiaal_vast != "") %>% 
  
    # remove whitespaces:
    mutate(materiaal_vast = str_trim(materiaal_vast)) %>% 

    # Add materials column to see if separation was correct:
    left_join(
      y = select(input_data, occurrence_id, materiaal_vast),
      by = "occurrence_id"
    ) %>% 
    rename("materiaal_vast_full" = "materiaal_vast.y",
           "materiaal_vast" = "materiaal_vast.x")
    
```

Separate on " = " and split in different columns:

```{r} 
sampling_protocol %<>% 
    separate(
      col = materiaal_vast,
      sep = "\\s=\\s",
      into = c("materiaal", "kwantiteit"))
```

remove "(aantal)" for easier mapping:

```{r} 
sampling_protocol %<>% 
   mutate(materiaal = str_remove(materiaal,"\\s\\(aantal\\)")) 
```

remove all rows for which `kwantiteit = NA

```{r}
sampling_protocol %<>% 
  filter(!is.na(kwantiteit))
```

Resulting materials:

```{r}
sampling_protocol %>% 
  select(materiaal) %>% 
  group_by_all() %>% 
  summarise(records = n())
```

Translate to English (generate `protocol`):

```{r}
sampling_protocol %<>% 
  mutate(protocol = recode(materiaal,
    "Andere" = "other",
    "Conibearklem" = "conibear trap(s)",
    "Fuik" = "fike(s)",
    "Grondklem" = "ground trap(s)",
    "Klemvlot" = "raft trap(s)",
    "Lokaasklem" = "bait trap(s)",
    "Materiaal verdwenen/kapot" = "material lost/broken",
    "Slagnet" = "spring net trap(s)",
    "Vangkooi" = "cage trap(s)",
    "Vangnet" = "net trap(s)",
    "Wildcamera" = "camera trap(s)"))
```

Add `effort` to the dataset. This is the sampling effort and is based on the values in `kwantiteit`:

```{r}
sampling_protocol %<>% 
  mutate(effort = case_when(
    kwantiteit == "0" ~ "",
    TRUE ~ paste(protocol, kwantiteit, sep = "=")))
```

Combine sampling efforts and methods per `occurrence_id`

```{r}
sampling_protocol <-
  sampling_protocol %>%
    group_by(occurrence_id) %>%
    summarise(sampling_protocol = paste(protocol, collapse = " | "),
              sampling_effort = paste(effort, collapse = " | "))
```

Now, the field `sampling_effort` contains some unwanted, repeated hashes. With this code, we remove them:

```{r}
sampling_protocol <- 
  sampling_protocol %>%
  
  # Split by one or more consecutive vertical pipes, i.e. |, || or |||, and return a list
  mutate(sampling_effort_new = str_split(.data$sampling_effort, pattern = "\\|+")) %>% 
  
  # remove heading or trailing spaces in each element of each list
  mutate(sampling_effort_new = map(.data$sampling_effort_new, ~ str_trim(.))) %>% 
  
  # remove empty or NA elements from list and convert to character by using " | " as delimiter
  mutate(sampling_effort_new = map_chr(
    .data$sampling_effort_new, function(x) paste(x[x != "" & !is.na(x)], collapse = " | ")
    )
  ) %>% 

  # convert empty strings to NA. empty strings arise in the last step when pasting a character(0) vector, i.e. the input sampling_effort_raw is missing (NA) as in row 6
  mutate(sampling_effort_new = ifelse(.data$sampling_effort_new == "",
                                      NA_character_,
                                      .data$sampling_effort_new)
)

```

Merge `sampling_protocol` with `input_data`:

```{r}
input_data %<>% left_join(
  y = sampling_protocol,
  by = "occurrence_id")
```

## Transform Lambert coordinates to WGS84

Coordinates in `x` and `y` are given in the Belgian Lambert system, they should be transformed to World Geodetic System 84 coordinate system

```{r}
input_data_sf <- 
  input_data %>%
     st_as_sf(coords = c("x", "y"), crs = 31370) %>%
     st_transform(crs = 4326) 
```

```{r}
x_y <- st_coordinates(input_data_sf)
```

```{r}
input_data <- 
  input_data %>% bind_cols(x_y) %>% 
    rename(decimal_latitude = Y) %>% 
    rename(decimal_longitude = X)
```

## Extract scientific name from GBIF code

Extract scientific names from GBIF based on `gbif_code`. First: extract all unique gbif_codes from `input_data`.

```{r}
gbif_codes <- input_data %>% select(gbif_code) %>% distinct()
```


```{r}
scientific_names <- 
  map_dfr(gbif_codes$gbif_code, function(x) {
  if (!is.na(x)) {
    name_usage(key = x)$data %>%
    select(key, scientificName, canonicalName, rank)}
  else {tibble(scientificName = NA_character_, canonicalName = NA_character_)}
  }) 
```

Add scientific names to `input_data`

```{r}
input_data <- 
  input_data %>% left_join(
    scientific_names,
    by = c("gbif_code" = "key"))
```

Clean `canonical_name` and `rank`:

```{r}
input_data <-
  input_data %>% 
    mutate(canonicalName_clean = case_when(
      soort == "Andere (soort vermelden):" & opmerkingen == "1 barberie gevangen, 1 verdwenen sinds vorige donderdag" ~ "Cairina moschata",
      soort == "Andere (soort vermelden):" & opmerkingen == "2 stuks roodwangschildpad" ~ "Trachemys scripta",
      soort == "Andere (soort vermelden):" & is.na(opmerkingen) ~ "unknown",
      soort == "Halsbandparkiet:" ~ "Psittacula krameri",
      soort == "Ganzenactie" ~ "Anatidae",
      soort == "gedomesticeerde gans" & opmerkingen == "Brandganzen" ~ "Branta leucopsis",
      soort == "gedomesticeerde gans" & opmerkingen == "Muskuseend"  ~ "Cairina moschata",
      soort == "gedomesticeerde gans" & is.na(opmerkingen) ~ "Anatidae",
      TRUE ~ canonicalName))
```

Clean `rank`:

```{r}
input_data <- input_data %>% 
    mutate(rank_clean = case_when(
      rank == "KINGDOM" & canonicalName_clean == "unknown" ~ "unknown",
      rank == "KINGDOM" & canonicalName_clean == "Anatidae" ~ "family",
      rank == "KINGDOM" & canonicalName_clean == "Cairina moschata" ~ "species",
      rank == "KINGDOM" & canonicalName_clean == "Trachemys scripta" ~ "species",
      rank == "KINGDOM" & canonicalName_clean == "Psittacula krameri" ~ "species",
      TRUE ~ rank)) %>% 
    mutate(rank_clean = str_to_lower(rank_clean))
```


Create `kingdom` from `domein`:

```{r}
input_data <- 
  input_data %>% 
    mutate(kingdom = case_when(
      domein == "Dier" ~ "Animalia",
      domein == "Plant" ~ "Plantae"))
```

# Darwin Core mapping

```{r}
input_data %<>% transmute(
  type = "Event",
  language = "en", 
  license = "http://creativecommons.org/publicdomain/zero/1.0/", 
  rightsHolder = "RATO", 
  datasetID = "", 
  institutionCode = "RATO", 
  datasetName = "RATO - daily operations commissioned by the province East Flanders, Belgium", 
  basisOfRecord = "humanObservation", 
  eventID = event_id, 
  occurrenceID = occurrence_id,
  recordedBy = "RATO", 
  organismQuantity = organism_quantity, 
  organismQuantityType = organism_quantity_type,
  occurrenceStatus = occurrence_status,
  samplingProtocol = sampling_protocol,
  samplingEffort = sampling_effort,
  eventDate = as.POSIXct(aangemaakt_datum), 
  countryCode = "BE", 
  municipality = gemeente,
  verbatimLatitude = y,
  verbatimLongitude = x,
  verbatimCoordinateSystem = "Lambert coordinates",
  verbatimSRS = "Belgian Datum 1972",
  decimalLatitude = decimal_latitude,
  decimalLongitude = decimal_longitude,
  geodeticDatum = "WGS84",
  coordinateUnvertainty = "30",
  scientificName = canonicalName_clean,
  kingdom = kingdom,
  taxonRank = rank_clean)
```

Save to CSV:

```{r} 
write_csv(input_data, here("data", "processed", "event.csv"), na = "")
```

